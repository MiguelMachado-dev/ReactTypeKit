{
  "Functional Component (const)": {
    "prefix": "rfc",
    "body": [
      "interface ${1:ComponentName}Props {",
      "  ${2:propName}: ${3:type};",
      "}",
      "",
      "const ${1:ComponentName} = ({ ${2:propName} }: ${1:ComponentName}Props) => {",
      "  return (",
      "    <div>",
      "      $0",
      "    </div>",
      "  );",
      "};",
      "",
      "export default ${1:ComponentName};"
    ],
    "description": "TS: React Functional Component"
  },
  "Functional Component (function)": {
    "prefix": "rff",
    "body": [
      "interface ${1:ComponentName}Props {",
      "  ${2:propName}: ${3:type};",
      "}",
      "",
      "export default function ${1:ComponentName}({ ${2:propName} }: ${1:ComponentName}Props) {",
      "  return (",
      "    <div>",
      "      $0",
      "    </div>",
      "  );",
      "}"
    ],
    "description": "TS: React Functional Component"
  },
  "useState Hook": {
    "prefix": "us",
    "body": [
      "const [${1:state}, set${1:state}] = useState<${3:type}>(${4:initialValue});"
    ],
    "description": "useState Hook with TypeScript"
  },
  "useEffect Hook run once at mount": {
    "prefix": "uem",
    "body": ["useEffect(() => {", "  $0", "}, []);"],
    "description": "useEffect Hook runs once at mount"
  },
  "useEffect Hook runs on every render": {
    "prefix": "uer",
    "body": ["useEffect(() => {", "  $0", "});"],
    "description": "useEffect Hook runs on every render"
  },
  "useEffect Hook Cleanup": {
    "prefix": "cleanup",
    "body": ["return () => {", " $0", "}"],
    "description": "useEffect Hook Cleanup"
  },
  "function": {
    "prefix": "func",
    "body": [
      "function ${1:name}(${2:params}: ${3:type}): ${4:returnType} {",
      "  $0",
      "}"
    ],
    "description": "Function"
  },
  "useMemo": {
    "prefix": "useMemo",
    "body": ["useMemo(() => {", "  $0", "}, [${1:deps}]);"],
    "description": "useMemo Hook"
  },
  "useCallback": {
    "prefix": "useCallback",
    "body": ["useCallback(() => {", "  $0", "}, [${1:deps}]);"],
    "description": "useCallback Hook"
  },
  "useRef": {
    "prefix": "useRef",
    "body": ["const ${1:ref} = useRef<${2:type}>(${3:initialValue});"],
    "description": "useRef Hook"
  },
  "useImperativeHandle": {
    "prefix": "uih",
    "body": ["useImperativeHandle(ref, () => ({", "  $0", "}), [${1:deps}]);"],
    "description": "useImperativeHandle Hook"
  },
  "useLayoutEffect": {
    "prefix": "useLayoutEffect",
    "body": ["useLayoutEffect(() => {", "  $0", "});"],
    "description": "useLayoutEffect Hook"
  },
  "useDebugValue": {
    "prefix": "useDebugValue",
    "body": ["useDebugValue(${1:value});"],
    "description": "useDebugValue Hook"
  },
  "useContext": {
    "prefix": "useContext",
    "body": ["useContext(${1:Context});"],
    "description": "useContext Hook"
  },
  "useReducer": {
    "prefix": "useReducer",
    "body": [
      "const [state, dispatch] = useReducer(${1:reducer}, ${2:initialState});"
    ],
    "description": "useReducer Hook"
  },
  "ForwardRef Component": {
    "prefix": "frc",
    "body": [
      "interface ${1:ComponentName}Props {",
      "  ${2:label}?: string;",
      "}",
      "",
      "const ${1:ComponentName} = forwardRef<${4:HTMLDivElement}, ${1:ComponentName}Props>(({ ${2:label} }, ref) => {",
      "  return (",
      "    <div ref={ref}>",
      "      {${2:label}}",
      "    </div>",
      "  );",
      "});",
      "",
      "${1:ComponentName}.displayName = '${1:ComponentName}';",
      "export default ${1:ComponentName};"
    ],
    "description": "ForwardRef component with props"
  },
  "Custom Hook Template": {
    "prefix": "hk",
    "body": [
      "function use${1:Custom}(initialValue: ${2:type}) {",
      "  const [state, setState] = useState<${2:type}>(initialValue);",
      "",
      "  const update = (value: ${2:type}) => {",
      "    setState(value);",
      "  };",
      "",
      "  return { state, update };",
      "}",
      "",
      "export default use${1:Custom};"
    ],
    "description": "Custom hook boilerplate"
  },
  "React Context (generic)": {
    "prefix": "rctx",
    "body": [
      "export interface ${1:ContextName}Value {",
      "  ${2:state}: ${3:string};",
      "  ${4:setState}: Dispatch<SetStateAction<${3:string}>>;",
      "}",
      "",
      "export const ${1:ContextName}Context = createContext<${1:ContextName}Value | null>(null);",
      "",
      "export function ${1:ContextName}Provider({ children, initial }: { children: ReactNode; initial?: ${3:string} }) {",
      "  const [${2:state}, ${4:setState}] = useState<${3:string}>(initial as ${3:string});",
      "  const value = useMemo(() => ({ ${2:state}, ${4:setState} }), [${2:state}]);",
      "  return (",
      "    <${1:ContextName}Context.Provider value={value}>",
      "      {children}",
      "    </${1:ContextName}Context.Provider>",
      "  );",
      "}",
      "",
      "export function ${5:use}${1:ContextName}() {",
      "  const ctx = useContext(${1:ContextName}Context);",
      "  if (!ctx) throw new Error('${5:use}${1:ContextName} must be used within a ${1:ContextName}Provider');",
      "  return ctx;",
      "}",
      "",
      "// Example usage:",
      "// <${1:ContextName}Provider initial={${6:/* initial value */} as ${3:string}}>...</${1:ContextName}Provider>",
      "// const { ${2:state}, ${4:setState} } = ${5:use}${1:ContextName}();"
    ],
    "description": "TS: Generic React Context with Provider and hook"
  },
  "Export Default": {
    "prefix": "exp",
    "body": ["export default ${1:expression};"],
    "description": "Export Default"
  },
  "Object to Destruct": {
    "prefix": "des",
    "body": ["const { ${1:prop} } = ${2:object};"],
    "description": "Object Destructuring"
  },
  "Const function": {
    "prefix": "cf",
    "body": [
      "const ${1:name} = (${2:params}: ${3:type}): ${4:returnType} => {",
      "  $0",
      "};"
    ],
    "description": "Const Function"
  },
  "Async/Await const function": {
    "prefix": "af",
    "body": [
      "const ${1:name} = async (${2:params}: ${3:type}): Promise<${4:returnType}> => {",
      "  try {",
      "    $0",
      "  } catch (error) {",
      "    console.error(error);",
      "    throw error;",
      "  }",
      "};"
    ],
    "description": "Async/Await Const Function with error handling"
  },
  "React Native Style": {
    "prefix": "rnstyle",
    "body": [
      "const styles = StyleSheet.create({",
      "  ${1:container}: {",
      "    ${2:property}: ${3:value},",
      "  },",
      "});"
    ],
    "description": "React Native StyleSheet"
  },
  "React Native Component (const)": {
    "prefix": "rnfc",
    "body": [
      "import React from 'react';",
      "import { View, Text, StyleSheet } from 'react-native';",
      "",
      "interface ${1:ComponentName}Props {",
      "  ${2:propName}: ${3:type};",
      "}",
      "",
      "const ${1:ComponentName} = ({ ${2:propName} }: ${1:ComponentName}Props) => {",
      "  return (",
      "    <View style={styles.container}>",
      "      <Text>${2:propName}: {${2:propName}}</Text>",
      "    </View>",
      "  );",
      "};",
      "",
      "const styles = StyleSheet.create({",
      "  container: {",
      "    flex: 1,",
      "    justifyContent: 'center',",
      "    alignItems: 'center',",
      "  },",
      "});",
      "",
      "export default ${1:ComponentName};"
    ],
    "description": "React Native Functional Component with TypeScript"
  },
  "Interface": {
    "prefix": "intr",
    "body": ["interface ${1:Name} {", "  ${2:prop}: ${3:type}$0", "}"],
    "description": "Interface"
  },
  "Type": {
    "prefix": "typ",
    "body": ["type ${1:Name} = ${2:type};"],
    "description": "Type"
  },
  "Enum": {
    "prefix": "enum",
    "body": ["enum ${1:Name} {", "  $0", "}"],
    "description": "Enum"
  },
  "Redux Toolkit configure store": {
    "prefix": "rts",
    "body": [
      "import { configureStore } from '@reduxjs/toolkit';",
      "import ${1:reducer} from './${1:reducer}Slice';",
      "",
      "const store = configureStore({",
      "  reducer: {",
      "    ${1:reducer},",
      "  },",
      "});",
      "",
      "export type RootState = ReturnType<typeof store.getState>;",
      "export type AppDispatch = typeof store.dispatch;",
      "export default store;"
    ],
    "description": "Redux Toolkit configure store with a sample reducer"
  },
  "Redux Toolkit Typed Hooks": {
    "prefix": "rtth",
    "body": [
      "import { TypedUseSelectorHook, useDispatch, useSelector } from 'react-redux';",
      "import type { RootState, AppDispatch } from './store';",
      "",
      "export const useAppDispatch = () => useDispatch<AppDispatch>();",
      "export const useAppSelector: TypedUseSelectorHook<RootState> = useSelector;"
    ],
    "description": "Redux Toolkit typed hooks for useDispatch and useSelector"
  },
  "Redux Toolkit Create Slice": {
    "prefix": "rtslice",
    "body": [
      "import { createSlice, type PayloadAction } from '@reduxjs/toolkit';",
      "",
      "interface ${1:SliceName}State {",
      "  ${2:property}: ${3:type};",
      "}",
      "",
      "const initialState: ${1:SliceName}State = {",
      "  ${2:property}: ${4:initialValue},",
      "};",
      "",
      "const ${1:SliceName}Slice = createSlice({",
      "  name: '${1:SliceName}',",
      "  initialState,",
      "  reducers: {",
      "    set${2/(.*)/${1:/capitalize}/}: (state, action: PayloadAction<${3:type}>) => {",
      "      state.${2} = action.payload;",
      "    },",
      "  },",
      "});",
      "",
      "export const { set${2/(.*)/${1:/capitalize}/} } = ${1:SliceName}Slice.actions;",
      "export default ${1:SliceName}Slice.reducer;"
    ],
    "description": "Redux Toolkit createSlice with state and a sample reducer"
  }
}
